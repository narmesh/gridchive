<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="GridChive is a professional grid generator for designers and developers. Create, customize, and export design grids effortlessly with precision and aesthetics."
    />
    <link rel="icon" type="image/webp" href="favicon.webp" />

    <title>GridChive - Professional Grid Generator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300..700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-primary: #0a0a0a;
        --bg-secondary: #141414;
        --bg-tertiary: #1a1a1a;
        --text-primary: #e5e5e5;
        --text-secondary: #a0a0a0;
        --text-tertiary: #666666;
        --accent: #6366f1;
        --accent-hover: #4f46e5;
        --border: #2a2a2a;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Space Grotesk", sans-serif;
        font-optical-sizing: auto;
        background: var(--bg-primary);
        color: var(--text-primary);
        line-height: 1.6;
        min-height: 100vh;
        overflow-x: hidden;
      }

      .app {
        display: grid;
        grid-template-columns: 280px 1fr;
        height: 100vh;
        position: relative;
      }

      /* Mobile Menu Toggle */
      .mobile-header {
        display: none;
        padding: 16px 20px;
        background: var(--bg-secondary);
        border-bottom: 1px solid var(--border);
        align-items: center;
        justify-content: space-between;
        position: sticky;
        top: 0;
        z-index: 100;
      }

      .mobile-header h1 {
        font-size: 18px;
        font-weight: 600;
      }

      .menu-toggle {
        width: 2rem;
        height: 2rem;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        border-radius: 2rem;
        padding: 0.2rem;
        cursor: pointer;
        color: var(--text-primary);
      }

      .menu-toggle:hover {
        border-color: var(--accent);
        color: var(--accent);
      }

      .menu-toggle svg {
        width: 24px;
        aspect-ratio: 24px;
        fill: currentColor;
      }

      /* Sidebar */
      .sidebar {
        background: var(--bg-secondary);
        border-right: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        transition: transform 0.3s ease;
      }

      /* .sidebar.mobile-hidden {
            transform: translateX(-100%);
        } */

      .logo {
        padding: 32px 24px 24px;
        border-bottom: 1px solid var(--border);
      }

      .logo h1 {
        font-size: 1.6rem;
        font-weight: 600;
        letter-spacing: -0.5px;
      }

      .logo p {
        font-size: 12px;
        color: var(--text-secondary);
        font-weight: 300;
      }

      .controls {
        padding: 24px;
        flex: 1;
      }

      .control-section {
        margin-bottom: 28px;
      }

      .section-label {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1.2px;
        color: var(--text-tertiary);
        margin-bottom: 16px;
        font-weight: 500;
      }

      .control-group {
        margin-bottom: 16px;
      }

      label {
        display: block;
        font-size: 13px;
        color: var(--text-secondary);
        margin-bottom: 8px;
        font-weight: 400;
      }

      select,
      input[type="number"] {
        width: 100%;
        padding: 10px 12px;
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        border-radius: 2rem;
        color: var(--text-primary);
        font-size: 13px;
        font-family: "Inter", sans-serif;
        transition: all 0.2s;
      }

      select:hover,
      input[type="number"]:hover {
        border-color: #3a3a3a;
      }

      select:focus,
      input[type="number"]:focus {
        outline: none;
        border-color: var(--accent);
        background: var(--bg-primary);
      }

      input[type="range"] {
        width: 100%;
        height: 4px;
        background: var(--bg-tertiary);
        border-radius: 2rem;
        outline: none;
        -webkit-appearance: none;
        appearance: none;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 14px;
        height: 14px;
        background: var(--accent);
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.2s;
      }

      input[type="range"]::-webkit-slider-thumb:hover {
        transform: scale(1.2);
        background: var(--accent-hover);
      }

      input[type="range"]::-moz-range-thumb {
        width: 14px;
        height: 14px;
        background: var(--accent);
        border: none;
        border-radius: 50%;
        cursor: pointer;
      }

      .range-display {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .range-value {
        font-size: 13px;
        color: var(--text-primary);
        font-weight: 500;
        font-variant-numeric: tabular-nums;
      }

      .color-control {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      input[type="color"] {
        width: 44px;
        height: 44px;
        border: 1px solid var(--border);
        border-radius: 2rem;
        background: var(--bg-tertiary);
        cursor: pointer;
        padding: 4px;
      }

      .color-hex {
        font-size: 13px;
        color: var(--text-secondary);
        font-family: "Courier New", monospace;
      }

      .checkbox-control {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
      }

      input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
        accent-color: var(--accent);
      }

      .actions {
        padding: 24px;
        border-top: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      button {
        width: 100%;
        padding: 11px 16px;
        border: none;
        border-radius: 2rem;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        font-family: "Inter", sans-serif;
      }

      .btn-primary {
        background: var(--accent);
        color: white;
      }

      .btn-primary:hover {
        background: var(--accent-hover);
      }

      .btn-secondary {
        background: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border);
      }

      .btn-secondary:hover {
        background: var(--bg-primary);
        border-color: #3a3a3a;
      }

      .btn-secondary svg {
        width: 18px;
        height: 18px;
        fill: currentColor;
      }

      /* Main Canvas Area */
      .canvas-area {
        display: flex;
        flex-direction: column;
        background: var(--bg-primary);
        min-height: 100vh;
      }

      .toolbar {
        padding: 16px 32px;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: var(--bg-secondary);
        flex-wrap: wrap;
        gap: 0.6rem;
      }

      .toolbar-left,
      .toolbar-right {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
      }

      .info-chip {
        padding: 0.4rem 0.8rem;
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        border-radius: 1rem;
        font-size: 12px;
        color: var(--text-secondary);
        font-variant-numeric: tabular-nums;
        white-space: nowrap;
      }

      .toolbar-btn {
        padding: 0.4rem;
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        border-radius: 2rem;
        color: var(--text-primary);
        cursor: pointer;
        transition: all 0.2s;
        width: 36px;
        aspect-ratio: 1;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .toolbar-btn:hover {
        border-color: var(--accent);
        color: var(--accent);
      }

      .toolbar-btn svg {
        width: 16px;
        height: 16px;
        fill: currentColor;
      }

      .toolbar-btn:active {
        transform: scale(0.95);
      }

      .canvas-container {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 40px 20px;
        overflow: auto;
      }

      #gridCanvas {
        box-shadow: 0 0 0 1px var(--border);
        border-radius: 6px;
        max-width: 100%;
        max-height: calc(100vh - 200px);
        object-fit: contain;
      }

      /* Preset Buttons */
      .preset-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }

      .preset-btn {
        padding: 8px 12px;
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        border-radius: 2rem;
        font-size: 12px;
        color: var(--text-secondary);
        cursor: pointer;
        transition: all 0.2s;
        text-align: left;
      }

      .preset-btn:hover {
        border-color: var(--accent);
        color: var(--text-primary);
      }

      .preset-btn.active {
        background: var(--accent);
        color: white;
        border-color: var(--accent);
      }

      /* Variation List */
      .variation-section {
        margin-top: 24px;
        padding-top: 24px;
        border-top: 1px solid var(--border);
      }

      .variation-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 12px;
      }

      .variation-item {
        padding: 10px 12px;
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 12px;
      }

      .variation-item:hover {
        border-color: var(--accent);
        background: var(--bg-primary);
      }

      .variation-item:active {
        transform: scale(0.98);
      }

      .variation-title {
        color: var(--text-primary);
        font-weight: 500;
      }

      .variation-details {
        color: var(--text-tertiary);
        font-size: 11px;
        display: flex;
        gap: 2px;
        flex-wrap: wrap;
      }

      .variation-details span {
        display: inline-block;
      }

      /* Responsive Design */
      @media (max-width: 1024px) {
        .app {
          grid-template-columns: 1fr;
        }

        .mobile-header {
          display: flex;
        }

        .sidebar {
          position: fixed;
          left: 0;
          top: 0;
          height: 100vh;
          z-index: 200;
          box-shadow: 4px 0 20px rgba(0, 0, 0, 0.5);
        }

        .sidebar.mobile-hidden {
          transform: translateX(-100%);
        }

        .logo {
          padding: 20px 24px 16px;
        }

        .toolbar {
          padding: 12px 20px;
        }

        .canvas-container {
          padding: 20px 16px;
        }

        #gridCanvas {
          max-height: calc(100vh - 150px);
        }

        .variation-list {
          gap: 6px;
        }

        .variation-item {
          padding: 8px 10px;
        }
      }

      @media (max-width: 640px) {
        .toolbar {
          flex-direction: column;
          align-items: flex-start;
        }

        .toolbar-left,
        .toolbar-right {
          width: 100%;
          justify-content: space-between;
        }

        .preset-grid {
          grid-template-columns: 1fr;
        }

        .variation-list {
          gap: 6px;
        }

        .variation-item {
          padding: 8px 10px;
        }
      }

      /* Scrollbar */
      ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }

      ::-webkit-scrollbar-track {
        background: var(--bg-secondary);
      }

      ::-webkit-scrollbar-thumb {
        background: var(--bg-tertiary);
        border-radius: 2rem;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: #2a2a2a;
      }

      /* Modal */
      .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(4px);
      }

      .modal-overlay.active {
        display: flex;
      }

      .modal {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 2rem;
        padding: 32px;
        max-width: 400px;
        width: 90%;
        animation: modalSlideIn 0.3s ease;
      }

      @keyframes modalSlideIn {
        from {
          opacity: 0;
          transform: translateY(-20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .modal-header {
        margin-bottom: 24px;
      }

      .modal-header h2 {
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 8px;
      }

      .modal-header p {
        font-size: 13px;
        color: var(--text-secondary);
      }

      .modal-options {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-bottom: 24px;
      }

      .modal-option {
        padding: 16px;
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 16px;
      }

      .modal-option:hover {
        border-color: var(--accent);
        background: var(--bg-primary);
      }

      .modal-option-icon {
        width: 40px;
        height: 40px;
        background: var(--accent);
        border-radius: 2rem;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }

      .modal-option-icon svg {
        width: 20px;
        height: 20px;
        fill: white;
      }

      .modal-option-content h3 {
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 4px;
      }

      .modal-option-content p {
        font-size: 12px;
        color: var(--text-secondary);
      }

      .modal-footer {
        display: flex;
        justify-content: flex-end;
      }

      .modal-close {
        padding: 10px 20px;
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        border-radius: 2rem;
        cursor: pointer;
        font-size: 13px;
        color: var(--text-primary);
        transition: all 0.2s;
      }

      .modal-close:hover {
        background: var(--bg-primary);
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .fade-in {
        animation: fadeIn 0.3s ease;
      }
    </style>
  </head>
  <body>
    <div class="mobile-header">
      <h1>GridChive</h1>
      <button class="menu-toggle" aria-label="Toggle menu" onclick="toggleMobileMenu()">
        <svg
          width="64px"
          height="64px"
          viewBox="0 0 24 24"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
          <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
          ></g>
          <g id="SVGRepo_iconCarrier">
            <g id="Menu / Menu_Alt_02">
              <path
                id="Vector"
                d="M11 17H19M5 12H19M11 7H19"
                stroke="#ffffff"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              ></path>
            </g>
          </g>
        </svg>
      </button>
    </div>

    <div class="app">
      <!-- Sidebar -->
      <aside class="sidebar mobile-hidden" id="sidebar">
        <div class="logo">
          <h1>GridChive</h1>
          <p>Professional grid systems</p>
        </div>

        <div class="controls">
          <div class="control-section">
            <div class="section-label">Grid System</div>
            <div class="control-group">
              <label for="gridType">Grid Type</label>
              <select id="gridType">
                <option value="golden">Golden Ratio</option>
                <option value="manuscript">Manuscript Grid</option>
                <option value="column">Column Grid</option>
                <option value="modular">Modular Grid</option>
                <option value="hierarchical">Hierarchical Grid</option>
                <option value="fibonacci">Fibonacci Spiral</option>
                <option value="swiss">Swiss Grid</option>
                <option value="baseline">Baseline Grid</option>
                <option value="asymmetric">Asymmetric Grid</option>
                <option value="compound">Compound Grid</option>
              </select>
            </div>
          </div>

          <div class="control-section">
            <div class="section-label">Canvas</div>
            <div class="control-group">
              <span class="section-label" style="margin-bottom: 0.5rem;">Preset</span>
              <div class="preset-grid">
                <button class="preset-btn" aria-label="Desktop HD preset" onclick="setPreset(1920, 1080)">
                  Desktop HD
                </button>
                <button class="preset-btn" aria-label="Laptop preset" onclick="setPreset(1440, 900)">
                  Laptop
                </button>
                <button class="preset-btn" aria-label="Tablet preset" onclick="setPreset(768, 1024)">
                  Tablet
                </button>
                <button class="preset-btn" aria-label="Mobile preset" onclick="setPreset(375, 812)">
                  Mobile
                </button>
                <button class="preset-btn" aria-label="Print A4 preset" onclick="setPreset(1200, 1600)">
                  Print A4
                </button>
                <button class="preset-btn" aria-label="2K Display preset" onclick="setPreset(2560, 1440)">
                  2K Display
                </button>
              </div>
            </div>
            <div class="control-group">
              <label for="canvasWidth">Width</label>
              <input
                type="number"
                id="canvasWidth"
                value="1440"
                min="320"
                max="4000"
                step="10"
              />
            </div>
            <div class="control-group">
              <label for="canvasHeight">Height</label>
              <input
                type="number"
                id="canvasHeight"
                value="900"
                min="320"
                max="4000"
                step="10"
              />
            </div>
          </div>

          <div class="control-section">
            <div class="section-label">Structure</div>
            <div class="control-group">
              <div class="range-display">
                <label for="columns">Columns</label>
                <span class="range-value" id="columnsValue">12</span>
              </div>
              <input type="range" id="columns" min="1" max="24" value="12" />
            </div>
            <div class="control-group">
              <div class="range-display">
                <label for="rows">Rows</label>
                <span class="range-value" id="rowsValue">8</span>
              </div>
              <input type="range" id="rows" min="1" max="24" value="8" />
            </div>
            <div class="control-group">
              <div class="range-display">
                <label for="gutter">Gutter</label>
                <span class="range-value" id="gutterValue">20px</span>
              </div>
              <input type="range" id="gutter" min="0" max="80" value="20" />
            </div>
            <div class="control-group">
              <div class="range-display">
                <label for="margin">Margin</label>
                <span class="range-value" id="marginValue">60px</span>
              </div>
              <input type="range" id="margin" min="0" max="200" value="60" />
            </div>
          </div>

          <div class="control-section">
            <div class="section-label">Appearance</div>
            <div class="control-group">
              <label for="gridColor">Grid Color</label>
              <div class="color-control">
                <input type="color" id="gridColor" value="#6366f1" />
                <span class="color-hex" id="gridColorHex">#6366f1</span>
              </div>
            </div>
            <div class="control-group">
              <div class="range-display">
                <label for="opacity">Opacity</label>
                <span class="range-value" id="opacityValue">30%</span>
              </div>
              <input type="range" id="opacity" min="5" max="100" value="30" />
            </div>
            <div class="control-group">
              <div class="range-display">
                <label for="lineWeight">Line Weight</label>
                <span class="range-value" id="lineWeightValue">1px</span>
              </div>
              <input
                type="range"
                id="lineWeight"
                min="0.5"
                max="4"
                step="0.5"
                value="1"
              />
            </div>
            <div class="control-group">
              <label class="checkbox-control">
                <input type="checkbox" id="showGuides" checked />
                <span>Show guides</span>
              </label>
            </div>
            <div class="control-group">
              <label class="checkbox-control">
                <input type="checkbox" id="showMargins" checked />
                <span>Show margins</span>
              </label>
            </div>
          </div>

          <div class="variation-section">
            <div class="section-label">Quick Variations</div>
            <div class="variation-list" id="variationList"></div>
          </div>
        </div>

        <div class="actions">
          <button class="btn-primary" aria-label="Generate grid" onclick="generateGrid()">
            Generate Grid
          </button>
          <button class="btn-secondary" aria-label="Export grid" onclick="openExportModal()">
            Export Grid
          </button>
          <button class="btn-secondary" aria-label="Generate new variations" onclick="generateVariations()">
            New Variations
          </button>
        </div>
      </aside>

      <!-- Main Canvas -->
      <main class="canvas-area">
        <div class="toolbar">
          <div class="toolbar-left">
            <div class="info-chip" id="dimensionInfo">1440 × 900</div>
            <div class="info-chip" id="ratioInfo">16:10</div>
            <div class="info-chip" id="gridInfo">12 col × 8 row</div>
          </div>
          <div class="toolbar-right">
            <button
              class="toolbar-btn"
              aria-label="Copy to clipboard"
              onclick="copyToClipboard()"
              title="Copy to clipboard"
            >
              <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"
                />
              </svg>
            </button>
            <button
              class="toolbar-btn"
              aria-label="Save configuration"
              onclick="downloadJSON()"
              title="Save config"
            >
              <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"
                />
              </svg>
            </button>
            <button
              class="toolbar-btn"
              aria-label="Generate random grid"
              onclick="randomize()"
              title="Random Grid"
            >
              <svg
                viewBox="0 0 32 32"
                version="1.1"
                xmlns="http://www.w3.org/2000/svg"
              >
                <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
                <g
                  id="SVGRepo_tracerCarrier"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                ></g>
                <g id="SVGRepo_iconCarrier">
                  <title>random</title>
                  <path
                    d="M0 24q0 0.832 0.576 1.44t1.44 0.576h1.984q2.048 0 3.904-0.8t3.168-2.144 2.144-3.2 0.8-3.872q0-2.464 1.728-4.224t4.256-1.76h4v1.984q0 0.672 0.384 1.152t0.864 0.704 1.12 0.128 1.056-0.544l4-4q0.608-0.64 0.576-1.44t-0.576-1.408l-4-4q-0.48-0.448-1.088-0.544t-1.12 0.128-0.864 0.704-0.352 1.12v2.016h-4q-2.016 0-3.872 0.8t-3.2 2.112-2.144 3.2-0.768 3.872q0 2.496-1.76 4.256t-4.256 1.76h-1.984q-0.832 0-1.44 0.576t-0.576 1.408zM0 8.032q0 0.832 0.576 1.408t1.44 0.576h1.984q1.408 0 2.592 0.608t2.080 1.664q0.672-2.048 1.984-3.68-2.912-2.592-6.656-2.592h-1.984q-0.832 0-1.44 0.608t-0.576 1.408zM13.376 23.456q2.848 2.56 6.624 2.56h4v2.016q0 0.64 0.384 1.152t0.864 0.704 1.12 0.096 1.056-0.544l4-4q0.608-0.608 0.576-1.44t-0.576-1.376l-4-4q-0.48-0.48-1.088-0.576t-1.12 0.128-0.864 0.736-0.352 1.12v1.984h-4q-1.376 0-2.592-0.576t-2.048-1.664q-0.704 2.048-1.984 3.68z"
                  ></path>
                </g>
              </svg>
            </button>
          </div>
        </div>
        <div class="canvas-container">
          <canvas id="gridCanvas"></canvas>
        </div>
      </main>
    </div>

    <!-- Export Modal -->
    <div
      class="modal-overlay"
      id="exportModal"
      onclick="closeExportModal(event)"
    >
      <div class="modal" onclick="event.stopPropagation()">
        <div class="modal-header">
          <h2>Export Grid</h2>
          <p>Choose your preferred export format</p>
        </div>
        <div class="modal-options">
          <div class="modal-option" onclick="exportPNG()">
            <div class="modal-option-icon">
              <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"
                />
              </svg>
            </div>
            <div class="modal-option-content">
              <h3>PNG Image</h3>
              <p>Raster format, ideal for presentations and web</p>
            </div>
          </div>
          <div class="modal-option" onclick="exportSVG()">
            <div class="modal-option-icon">
              <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z" />
              </svg>
            </div>
            <div class="modal-option-content">
              <h3>SVG Vector</h3>
              <p>Scalable format, perfect for design tools</p>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="modal-close" aria-label="Close modal" onclick="closeExportModal()">
            Cancel
          </button>
        </div>
      </div>
    </div>

    <script>
      const PHI = 1.618033988749895;
      const canvas = document.getElementById("gridCanvas");
      const ctx = canvas.getContext("2d");
      let currentConfig = null;

      // Advanced variation generation system
      const GRID_TEMPLATES = {
        golden: {
          columns: [8, 12, 16],
          rows: [6, 8, 12],
          gutters: [16, 20, 24, 32],
          margins: [40, 60, 80, 100],
          features: ["spiral", "sections", "grid"],
        },
        manuscript: {
          columns: [2, 3, 4],
          rows: [12, 16, 20],
          gutters: [12, 16, 20],
          margins: [60, 80, 100, 120],
          features: ["baseline", "textblock"],
        },
        column: {
          columns: [6, 8, 10, 12, 16],
          rows: [1],
          gutters: [16, 20, 24, 28, 32],
          margins: [40, 60, 80],
          features: ["vertical"],
        },
        modular: {
          columns: [6, 8, 10, 12],
          rows: [6, 8, 10, 12],
          gutters: [16, 20, 24],
          margins: [40, 60, 80],
          features: ["modules", "hierarchy"],
        },
        hierarchical: {
          columns: [12, 16, 20],
          rows: [8, 12, 16],
          gutters: [12, 16, 20],
          margins: [40, 60, 80],
          features: ["levels", "emphasis"],
        },
        fibonacci: {
          columns: [1],
          rows: [1],
          gutters: [0],
          margins: [40, 60, 80],
          features: ["spiral", "organic"],
        },
        swiss: {
          columns: [8, 10, 12, 16],
          rows: [8, 10, 12],
          gutters: [16, 20, 24],
          margins: [60, 80, 100],
          features: ["asymmetric", "focal"],
        },
        baseline: {
          columns: [6, 8, 10, 12],
          rows: [24, 32, 40],
          gutters: [16, 20, 24],
          margins: [40, 60, 80],
          features: ["rhythm", "typography"],
        },
        asymmetric: {
          columns: [7, 9, 11, 13],
          rows: [5, 7, 9],
          gutters: [12, 16, 20, 24],
          margins: [40, 60, 80, 100],
          features: ["tension", "dynamic"],
        },
        compound: {
          columns: [12, 16, 18],
          rows: [9, 12, 15],
          gutters: [16, 20, 24],
          margins: [60, 80, 100],
          features: ["complex", "layered"],
        },
      };

      const COLOR_PALETTES = [
        ["#6366f1", "#8b5cf6", "#ec4899"],
        ["#06b6d4", "#0ea5e9", "#3b82f6"],
        ["#10b981", "#14b8a6", "#22c55e"],
        ["#f59e0b", "#f97316", "#ef4444"],
        ["#8b5cf6", "#a855f7", "#c026d3"],
        ["#64748b", "#475569", "#334155"],
      ];

      function fibonacci(n) {
        const fib = [1, 1];
        for (let i = 2; i < n; i++) {
          fib[i] = fib[i - 1] + fib[i - 2];
        }
        return fib;
      }

      function gcd(a, b) {
        return b === 0 ? a : gcd(b, a % b);
      }

      function random(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
      }

      function randomRange(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function toggleMobileMenu() {
        document.getElementById("sidebar").classList.toggle("mobile-hidden");
      }

      function setupControls() {
        const ranges = {
          columns: { display: "columnsValue", suffix: "" },
          rows: { display: "rowsValue", suffix: "" },
          gutter: { display: "gutterValue", suffix: "px" },
          margin: { display: "marginValue", suffix: "px" },
          opacity: { display: "opacityValue", suffix: "%" },
          lineWeight: { display: "lineWeightValue", suffix: "px" },
        };

        Object.entries(ranges).forEach(([id, config]) => {
          const elem = document.getElementById(id);
          const display = document.getElementById(config.display);
          elem.addEventListener("input", (e) => {
            display.textContent = e.target.value + config.suffix;
            updateToolbar();
          });
        });

        document.getElementById("gridColor").addEventListener("input", (e) => {
          document.getElementById("gridColorHex").textContent = e.target.value;
        });

        ["canvasWidth", "canvasHeight"].forEach((id) => {
          document.getElementById(id).addEventListener("input", updateToolbar);
        });

        ["gridType", "showGuides", "showMargins"].forEach((id) => {
          document.getElementById(id).addEventListener("change", generateGrid);
        });
      }

      function updateToolbar() {
        const width = parseInt(document.getElementById("canvasWidth").value);
        const height = parseInt(document.getElementById("canvasHeight").value);
        const columns = parseInt(document.getElementById("columns").value);
        const rows = parseInt(document.getElementById("rows").value);

        document.getElementById(
          "dimensionInfo"
        ).textContent = `${width} × ${height}`;

        const divisor = gcd(width, height);
        document.getElementById("ratioInfo").textContent = `${
          width / divisor
        }:${height / divisor}`;

        document.getElementById(
          "gridInfo"
        ).textContent = `${columns} col × ${rows} row`;
      }

      function setPreset(width, height) {
        document.getElementById("canvasWidth").value = width;
        document.getElementById("canvasHeight").value = height;
        updateToolbar();
        generateGrid();

        // Close mobile menu if open
        if (window.innerWidth <= 1024) {
          document.getElementById("sidebar").classList.add("mobile-hidden");
        }
      }

      function getConfig() {
        return {
          width: parseInt(document.getElementById("canvasWidth").value),
          height: parseInt(document.getElementById("canvasHeight").value),
          columns: parseInt(document.getElementById("columns").value),
          rows: parseInt(document.getElementById("rows").value),
          gutter: parseInt(document.getElementById("gutter").value),
          margin: parseInt(document.getElementById("margin").value),
          gridType: document.getElementById("gridType").value,
          color: document.getElementById("gridColor").value,
          opacity: parseInt(document.getElementById("opacity").value) / 100,
          lineWeight: parseFloat(document.getElementById("lineWeight").value),
          showGuides: document.getElementById("showGuides").checked,
          showMargins: document.getElementById("showMargins").checked,
        };
      }

      function generateGrid() {
        const cfg = getConfig();
        currentConfig = cfg;

        canvas.width = cfg.width;
        canvas.height = cfg.height;

        ctx.fillStyle = "#0f0f0f";
        ctx.fillRect(0, 0, cfg.width, cfg.height);

        drawGrid(cfg);
        canvas.classList.add("fade-in");
        setTimeout(() => canvas.classList.remove("fade-in"), 300);
      }

      function drawGrid(cfg) {
        switch (cfg.gridType) {
          case "golden":
            drawGoldenGrid(cfg);
            break;
          case "manuscript":
            drawManuscriptGrid(cfg);
            break;
          case "column":
            drawColumnGrid(cfg);
            break;
          case "modular":
            drawModularGrid(cfg);
            break;
          case "hierarchical":
            drawHierarchicalGrid(cfg);
            break;
          case "fibonacci":
            drawFibonacciGrid(cfg);
            break;
          case "swiss":
            drawSwissGrid(cfg);
            break;
          case "baseline":
            drawBaselineGrid(cfg);
            break;
          case "asymmetric":
            drawAsymmetricGrid(cfg);
            break;
          case "compound":
            drawCompoundGrid(cfg);
            break;
        }

        if (cfg.showMargins) drawMargins(cfg);
      }

      function drawMargins(cfg) {
        ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 0.3);
        ctx.lineWidth = cfg.lineWeight;
        ctx.setLineDash([4, 4]);
        ctx.strokeRect(
          cfg.margin,
          cfg.margin,
          cfg.width - 2 * cfg.margin,
          cfg.height - 2 * cfg.margin
        );
        ctx.setLineDash([]);
      }

      function drawGoldenGrid(cfg) {
        const workWidth = cfg.width - 2 * cfg.margin;
        const workHeight = cfg.height - 2 * cfg.margin;

        ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity);
        ctx.lineWidth = cfg.lineWeight;

        const goldenX = cfg.margin + workWidth / PHI;
        const goldenXAlt = cfg.margin + workWidth - workWidth / PHI;

        ctx.beginPath();
        ctx.moveTo(goldenX, cfg.margin);
        ctx.lineTo(goldenX, cfg.height - cfg.margin);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(goldenXAlt, cfg.margin);
        ctx.lineTo(goldenXAlt, cfg.height - cfg.margin);
        ctx.stroke();

        const goldenY = cfg.margin + workHeight / PHI;
        const goldenYAlt = cfg.margin + workHeight - workHeight / PHI;

        ctx.beginPath();
        ctx.moveTo(cfg.margin, goldenY);
        ctx.lineTo(cfg.width - cfg.margin, goldenY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(cfg.margin, goldenYAlt);
        ctx.lineTo(cfg.width - cfg.margin, goldenYAlt);
        ctx.stroke();

        const colWidth = workWidth / cfg.columns;
        for (let i = 0; i <= cfg.columns; i++) {
          const x = cfg.margin + i * colWidth;
          ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 0.4);
          ctx.lineWidth = cfg.lineWeight * 0.5;
          ctx.beginPath();
          ctx.moveTo(x, cfg.margin);
          ctx.lineTo(x, cfg.height - cfg.margin);
          ctx.stroke();
        }

        const rowHeight = workHeight / cfg.rows;
        for (let i = 0; i <= cfg.rows; i++) {
          const y = cfg.margin + i * rowHeight;
          ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 0.4);
          ctx.lineWidth = cfg.lineWeight * 0.5;
          ctx.beginPath();
          ctx.moveTo(cfg.margin, y);
          ctx.lineTo(cfg.width - cfg.margin, y);
          ctx.stroke();
        }

        if (cfg.showGuides) {
          ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 1.2);
          ctx.lineWidth = cfg.lineWeight * 1.5;
          drawGoldenSpiral(cfg.margin, cfg.margin, workWidth, workHeight);
        }
      }

      function drawGoldenSpiral(x, y, w, h) {
        let size = Math.min(w, h);
        let currentX = x,
          currentY = y;
        let direction = 0;

        for (let i = 0; i < 6; i++) {
          ctx.beginPath();
          switch (direction % 4) {
            case 0:
              ctx.arc(
                currentX + size,
                currentY + size,
                size,
                Math.PI,
                1.5 * Math.PI
              );
              currentY += size;
              break;
            case 1:
              ctx.arc(
                currentX,
                currentY + size,
                size,
                1.5 * Math.PI,
                2 * Math.PI
              );
              currentX += size;
              break;
            case 2:
              ctx.arc(currentX, currentY, size, 0, 0.5 * Math.PI);
              break;
            case 3:
              ctx.arc(currentX, currentY, size, 0.5 * Math.PI, Math.PI);
              break;
          }
          ctx.stroke();
          size = size / PHI;
          direction++;
        }
      }

      function drawManuscriptGrid(cfg) {
        const workWidth = cfg.width - 2 * cfg.margin;
        const workHeight = cfg.height - 2 * cfg.margin;

        const textBlockWidth = workWidth * 0.618;
        const textBlockHeight = workHeight * 0.618;

        const startX = cfg.margin + (workWidth - textBlockWidth) / 2;
        const startY = cfg.margin + (workHeight - textBlockHeight) / 2;

        ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity);
        ctx.lineWidth = cfg.lineWeight * 1.5;
        ctx.strokeRect(startX, startY, textBlockWidth, textBlockHeight);

        const gutterSpace = cfg.gutter;
        const columnWidth =
          (textBlockWidth - gutterSpace * (cfg.columns - 1)) / cfg.columns;

        ctx.lineWidth = cfg.lineWeight;
        for (let i = 0; i <= cfg.columns; i++) {
          const x = startX + i * (columnWidth + gutterSpace);
          ctx.beginPath();
          ctx.moveTo(x, startY);
          ctx.lineTo(x, startY + textBlockHeight);
          ctx.stroke();
        }

        const baselineSpacing = textBlockHeight / (cfg.rows * 2);
        ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 0.3);
        ctx.lineWidth = cfg.lineWeight * 0.5;

        for (let i = 0; i <= cfg.rows * 2; i++) {
          const y = startY + i * baselineSpacing;
          ctx.beginPath();
          ctx.moveTo(startX, y);
          ctx.lineTo(startX + textBlockWidth, y);
          ctx.stroke();
        }
      }

      function drawColumnGrid(cfg) {
        const workWidth = cfg.width - 2 * cfg.margin;
        const workHeight = cfg.height - 2 * cfg.margin;

        const totalGutter = cfg.gutter * (cfg.columns - 1);
        const columnWidth = (workWidth - totalGutter) / cfg.columns;

        ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity);
        ctx.lineWidth = cfg.lineWeight;

        for (let i = 0; i <= cfg.columns; i++) {
          const x = cfg.margin + i * (columnWidth + cfg.gutter);
          ctx.beginPath();
          ctx.moveTo(x, cfg.margin);
          ctx.lineTo(x, cfg.height - cfg.margin);
          ctx.stroke();
        }

        ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 0.25);
        ctx.lineWidth = cfg.lineWeight * 0.5;

        const guides = [1 / 4, 1 / 3, 1 / 2, 2 / 3, 3 / 4];
        guides.forEach((ratio) => {
          const y = cfg.margin + workHeight * ratio;
          ctx.beginPath();
          ctx.moveTo(cfg.margin, y);
          ctx.lineTo(cfg.width - cfg.margin, y);
          ctx.stroke();
        });
      }

      function drawModularGrid(cfg) {
        const workWidth = cfg.width - 2 * cfg.margin;
        const workHeight = cfg.height - 2 * cfg.margin;

        const totalGutterX = cfg.gutter * (cfg.columns - 1);
        const totalGutterY = cfg.gutter * (cfg.rows - 1);
        const moduleWidth = (workWidth - totalGutterX) / cfg.columns;
        const moduleHeight = (workHeight - totalGutterY) / cfg.rows;

        ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity);
        ctx.lineWidth = cfg.lineWeight;

        for (let i = 0; i <= cfg.columns; i++) {
          const x = cfg.margin + i * (moduleWidth + cfg.gutter);
          ctx.beginPath();
          ctx.moveTo(x, cfg.margin);
          ctx.lineTo(x, cfg.height - cfg.margin);
          ctx.stroke();
        }

        for (let i = 0; i <= cfg.rows; i++) {
          const y = cfg.margin + i * (moduleHeight + cfg.gutter);
          ctx.beginPath();
          ctx.moveTo(cfg.margin, y);
          ctx.lineTo(cfg.width - cfg.margin, y);
          ctx.stroke();
        }

        if (cfg.showGuides) {
          ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 1.5);
          ctx.lineWidth = cfg.lineWeight * 2;

          const majorCols = [
            Math.floor(cfg.columns / 3),
            Math.floor((2 * cfg.columns) / 3),
          ];
          majorCols.forEach((col) => {
            const x = cfg.margin + col * (moduleWidth + cfg.gutter);
            ctx.beginPath();
            ctx.moveTo(x, cfg.margin);
            ctx.lineTo(x, cfg.height - cfg.margin);
            ctx.stroke();
          });
        }
      }

      function drawHierarchicalGrid(cfg) {
        const workWidth = cfg.width - 2 * cfg.margin;
        const workHeight = cfg.height - 2 * cfg.margin;

        ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity);
        ctx.lineWidth = cfg.lineWeight * 2;

        const primaryCols = Math.ceil(cfg.columns / 4);
        for (let i = 0; i <= primaryCols; i++) {
          const x = cfg.margin + (workWidth * i) / primaryCols;
          ctx.beginPath();
          ctx.moveTo(x, cfg.margin);
          ctx.lineTo(x, cfg.height - cfg.margin);
          ctx.stroke();
        }

        const primaryRows = Math.ceil(cfg.rows / 4);
        for (let i = 0; i <= primaryRows; i++) {
          const y = cfg.margin + (workHeight * i) / primaryRows;
          ctx.beginPath();
          ctx.moveTo(cfg.margin, y);
          ctx.lineTo(cfg.width - cfg.margin, y);
          ctx.stroke();
        }

        ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 0.6);
        ctx.lineWidth = cfg.lineWeight;

        for (let i = 0; i <= cfg.columns; i++) {
          if (i % 4 === 0) continue;
          const x = cfg.margin + (workWidth * i) / cfg.columns;
          ctx.beginPath();
          ctx.moveTo(x, cfg.margin);
          ctx.lineTo(x, cfg.height - cfg.margin);
          ctx.stroke();
        }

        for (let i = 0; i <= cfg.rows; i++) {
          if (i % 4 === 0) continue;
          const y = cfg.margin + (workHeight * i) / cfg.rows;
          ctx.beginPath();
          ctx.moveTo(cfg.margin, y);
          ctx.lineTo(cfg.width - cfg.margin, y);
          ctx.stroke();
        }
      }

      function drawFibonacciGrid(cfg) {
        const workWidth = cfg.width - 2 * cfg.margin;
        const workHeight = cfg.height - 2 * cfg.margin;

        const fib = fibonacci(12);
        const maxFib = fib[fib.length - 1];
        const scale = Math.min(workWidth, workHeight) / maxFib;

        ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 0.8);
        ctx.lineWidth = cfg.lineWeight;

        let x = cfg.margin,
          y = cfg.margin,
          w = workWidth,
          h = workHeight;
        let direction = 0;

        for (let i = fib.length - 1; i >= 3; i--) {
          const size = fib[i] * scale;

          if (direction % 2 === 0) {
            ctx.strokeRect(x, y, Math.min(size, w), h);
          } else {
            ctx.strokeRect(x, y, w, Math.min(size, h));
          }

          if (cfg.showGuides) {
            ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 1.2);
            ctx.lineWidth = cfg.lineWeight * 1.5;

            ctx.beginPath();
            switch (direction % 4) {
              case 0:
                ctx.arc(x + size, y + size, size, Math.PI, 1.5 * Math.PI);
                y += size;
                h -= size;
                break;
              case 1:
                ctx.arc(x, y + size, size, 1.5 * Math.PI, 2 * Math.PI);
                x += size;
                w -= size;
                break;
              case 2:
                ctx.arc(x, y, size, 0, 0.5 * Math.PI);
                h = size;
                break;
              case 3:
                ctx.arc(x, y, size, 0.5 * Math.PI, Math.PI);
                w = size;
                break;
            }
            ctx.stroke();
            ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 0.8);
            ctx.lineWidth = cfg.lineWeight;
          }
          direction++;
        }
      }

      function drawSwissGrid(cfg) {
        const workWidth = cfg.width - 2 * cfg.margin;
        const workHeight = cfg.height - 2 * cfg.margin;

        ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity);
        ctx.lineWidth = cfg.lineWeight;

        for (let i = 0; i <= cfg.columns; i++) {
          const x = cfg.margin + (workWidth * i) / cfg.columns;
          ctx.beginPath();
          ctx.moveTo(x, cfg.margin);
          ctx.lineTo(x, cfg.height - cfg.margin);
          ctx.stroke();
        }

        const rows = Math.floor(cfg.columns * (cfg.height / cfg.width));
        for (let i = 0; i <= rows; i++) {
          const y = cfg.margin + (workHeight * i) / rows;
          ctx.beginPath();
          ctx.moveTo(cfg.margin, y);
          ctx.lineTo(cfg.width - cfg.margin, y);
          ctx.stroke();
        }

        if (cfg.showGuides) {
          ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 1.5);
          ctx.lineWidth = cfg.lineWeight * 2;

          const x1 = cfg.margin + workWidth / 3;
          ctx.beginPath();
          ctx.moveTo(x1, cfg.margin);
          ctx.lineTo(x1, cfg.height - cfg.margin);
          ctx.stroke();

          const y1 = cfg.margin + workHeight / PHI;
          ctx.beginPath();
          ctx.moveTo(cfg.margin, y1);
          ctx.lineTo(cfg.width - cfg.margin, y1);
          ctx.stroke();
        }
      }

      function drawBaselineGrid(cfg) {
        const workWidth = cfg.width - 2 * cfg.margin;
        const workHeight = cfg.height - 2 * cfg.margin;

        const baselineUnit = 8;
        const scaleFactor = Math.max(1, Math.floor(workHeight / 800));
        const baseline = baselineUnit * scaleFactor;

        const totalGutter = cfg.gutter * (cfg.columns - 1);
        const columnWidth = (workWidth - totalGutter) / cfg.columns;

        ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity);
        ctx.lineWidth = cfg.lineWeight;

        for (let i = 0; i <= cfg.columns; i++) {
          const x = cfg.margin + i * (columnWidth + cfg.gutter);
          ctx.beginPath();
          ctx.moveTo(x, cfg.margin);
          ctx.lineTo(x, cfg.height - cfg.margin);
          ctx.stroke();
        }

        let y = cfg.margin;
        let count = 0;
        while (y <= cfg.height - cfg.margin) {
          if (count % 4 === 0) {
            ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 0.7);
            ctx.lineWidth = cfg.lineWeight;
          } else {
            ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 0.3);
            ctx.lineWidth = cfg.lineWeight * 0.5;
          }

          ctx.beginPath();
          ctx.moveTo(cfg.margin, y);
          ctx.lineTo(cfg.width - cfg.margin, y);
          ctx.stroke();

          y += baseline;
          count++;
        }
      }

      function drawAsymmetricGrid(cfg) {
        const workWidth = cfg.width - 2 * cfg.margin;
        const workHeight = cfg.height - 2 * cfg.margin;

        ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity);
        ctx.lineWidth = cfg.lineWeight;

        const ratios = [0.382, 0.618, 0.236, 0.764];
        ratios.forEach((ratio) => {
          const x = cfg.margin + workWidth * ratio;
          ctx.beginPath();
          ctx.moveTo(x, cfg.margin);
          ctx.lineTo(x, cfg.height - cfg.margin);
          ctx.stroke();
        });

        ratios.forEach((ratio) => {
          const y = cfg.margin + workHeight * ratio;
          ctx.beginPath();
          ctx.moveTo(cfg.margin, y);
          ctx.lineTo(cfg.width - cfg.margin, y);
          ctx.stroke();
        });

        ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 0.4);
        ctx.lineWidth = cfg.lineWeight * 0.5;

        for (let i = 1; i < cfg.columns; i++) {
          const x = cfg.margin + (workWidth * i) / cfg.columns;
          ctx.beginPath();
          ctx.moveTo(x, cfg.margin);
          ctx.lineTo(x, cfg.height - cfg.margin);
          ctx.stroke();
        }

        for (let i = 1; i < cfg.rows; i++) {
          const y = cfg.margin + (workHeight * i) / cfg.rows;
          ctx.beginPath();
          ctx.moveTo(cfg.margin, y);
          ctx.lineTo(cfg.width - cfg.margin, y);
          ctx.stroke();
        }
      }

      function drawCompoundGrid(cfg) {
        const workWidth = cfg.width - 2 * cfg.margin;
        const workHeight = cfg.height - 2 * cfg.margin;

        ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 1.2);
        ctx.lineWidth = cfg.lineWeight * 1.5;

        const majorCols = 4;
        for (let i = 0; i <= majorCols; i++) {
          const x = cfg.margin + (workWidth * i) / majorCols;
          ctx.beginPath();
          ctx.moveTo(x, cfg.margin);
          ctx.lineTo(x, cfg.height - cfg.margin);
          ctx.stroke();
        }

        const majorRows = 3;
        for (let i = 0; i <= majorRows; i++) {
          const y = cfg.margin + (workHeight * i) / majorRows;
          ctx.beginPath();
          ctx.moveTo(cfg.margin, y);
          ctx.lineTo(cfg.width - cfg.margin, y);
          ctx.stroke();
        }

        ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 0.6);
        ctx.lineWidth = cfg.lineWeight;

        for (let i = 0; i <= cfg.columns; i++) {
          const x = cfg.margin + (workWidth * i) / cfg.columns;
          ctx.beginPath();
          ctx.moveTo(x, cfg.margin);
          ctx.lineTo(x, cfg.height - cfg.margin);
          ctx.stroke();
        }

        for (let i = 0; i <= cfg.rows; i++) {
          const y = cfg.margin + (workHeight * i) / cfg.rows;
          ctx.beginPath();
          ctx.moveTo(cfg.margin, y);
          ctx.lineTo(cfg.width - cfg.margin, y);
          ctx.stroke();
        }

        if (cfg.showGuides) {
          ctx.strokeStyle = hexToRgba(cfg.color, cfg.opacity * 0.3);
          ctx.lineWidth = cfg.lineWeight * 0.5;

          const x1 = cfg.margin + workWidth / PHI;
          ctx.beginPath();
          ctx.moveTo(x1, cfg.margin);
          ctx.lineTo(x1, cfg.height - cfg.margin);
          ctx.stroke();

          const y1 = cfg.margin + workHeight / PHI;
          ctx.beginPath();
          ctx.moveTo(cfg.margin, y1);
          ctx.lineTo(cfg.width - cfg.margin, y1);
          ctx.stroke();
        }
      }

      function generateVariations() {
        const gridType = document.getElementById("gridType").value;
        const template = GRID_TEMPLATES[gridType];
        const variationList = document.getElementById("variationList");

        variationList.innerHTML = "";

        for (let i = 0; i < 6; i++) {
          const variation = {
            columns: random(template.columns),
            rows: random(template.rows),
            gutter: random(template.gutters),
            margin: random(template.margins),
            color: random(random(COLOR_PALETTES)),
            opacity: randomRange(20, 50) / 100,
            lineWeight: random([0.5, 1, 1.5, 2]),
          };

          const item = document.createElement("div");
          item.className = "variation-item";
          item.onclick = () => applyVariation(variation);

          const title = document.createElement("div");
          title.className = "variation-title";
          title.textContent = `V ${i + 1}`;

          const details = document.createElement("div");
          details.className = "variation-details";
          details.innerHTML = `
                    <span>${variation.columns}×${variation.rows}</span>
                    <span>•</span>
                    <span>G:${variation.gutter}px</span>
                    <span>•</span>
                    <span>M:${variation.margin}px</span>
                    <span>•</span>
                    <span>W:${variation.lineWeight}px</span>
                `;

          item.appendChild(title);
          item.appendChild(details);
          variationList.appendChild(item);
        }
      }

      function applyVariation(variation) {
        document.getElementById("columns").value = variation.columns;
        document.getElementById("rows").value = variation.rows;
        document.getElementById("gutter").value = variation.gutter;
        document.getElementById("margin").value = variation.margin;
        document.getElementById("gridColor").value = variation.color;
        document.getElementById("opacity").value = Math.round(
          variation.opacity * 100
        );
        document.getElementById("lineWeight").value = variation.lineWeight;

        document.getElementById("columnsValue").textContent = variation.columns;
        document.getElementById("rowsValue").textContent = variation.rows;
        document.getElementById("gutterValue").textContent =
          variation.gutter + "px";
        document.getElementById("marginValue").textContent =
          variation.margin + "px";
        document.getElementById("gridColorHex").textContent = variation.color;
        document.getElementById("opacityValue").textContent =
          Math.round(variation.opacity * 100) + "%";
        document.getElementById("lineWeightValue").textContent =
          variation.lineWeight + "px";

        generateGrid();

        if (window.innerWidth <= 1024) {
          document.getElementById("sidebar").classList.add("mobile-hidden");
        }
      }

      function randomize() {
        const types = Object.keys(GRID_TEMPLATES);
        const type = random(types);
        const template = GRID_TEMPLATES[type];

        document.getElementById("gridType").value = type;
        document.getElementById("columns").value = random(template.columns);
        document.getElementById("rows").value = random(template.rows);
        document.getElementById("gutter").value = random(template.gutters);
        document.getElementById("margin").value = random(template.margins);
        document.getElementById("gridColor").value = random(
          random(COLOR_PALETTES)
        );
        document.getElementById("opacity").value = randomRange(20, 60);
        document.getElementById("lineWeight").value = random([0.5, 1, 1.5, 2]);

        document.getElementById("columnsValue").textContent =
          document.getElementById("columns").value;
        document.getElementById("rowsValue").textContent =
          document.getElementById("rows").value;
        document.getElementById("gutterValue").textContent =
          document.getElementById("gutter").value + "px";
        document.getElementById("marginValue").textContent =
          document.getElementById("margin").value + "px";
        document.getElementById("gridColorHex").textContent =
          document.getElementById("gridColor").value;
        document.getElementById("opacityValue").textContent =
          document.getElementById("opacity").value + "%";
        document.getElementById("lineWeightValue").textContent =
          document.getElementById("lineWeight").value + "px";

        updateToolbar();
        generateGrid();
        generateVariations();
      }

      function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      function openExportModal() {
        document.getElementById("exportModal").classList.add("active");
      }

      function closeExportModal(event) {
        if (!event || event.target.classList.contains("modal-overlay")) {
          document.getElementById("exportModal").classList.remove("active");
        }
      }

      function exportSVG() {
        const gridType = document.getElementById("gridType").value;
        const svgData = canvas.toDataURL("image/png");

        let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="${currentConfig.width}" height="${currentConfig.height}" viewBox="0 0 ${currentConfig.width} ${currentConfig.height}">
  <title>GridChive - ${gridType}</title>
  <image width="${currentConfig.width}" height="${currentConfig.height}" xlink:href="${svgData}"/>
</svg>`;

        const blob = new Blob([svg], { type: "image/svg+xml" });
        downloadBlob(blob, `gridchive-${gridType}-${Date.now()}.svg`);
        closeExportModal();
      }

      function exportPNG() {
        const gridType = document.getElementById("gridType").value;
        canvas.toBlob((blob) => {
          downloadBlob(blob, `gridchive-${gridType}-${Date.now()}.png`);
        });
      }

      function copyToClipboard() {
        canvas.toBlob((blob) => {
          if (navigator.clipboard && navigator.clipboard.write) {
            navigator.clipboard
              .write([new ClipboardItem({ "image/png": blob })])
              .then(() => {
                showNotification("Grid copied to clipboard!");
              })
              .catch(() => {
                showNotification(
                  "Failed to copy. Try export instead.",
                  "error"
                );
              });
          } else {
            showNotification(
              "Clipboard not supported. Use export instead.",
              "error"
            );
          }
        });
      }

      function downloadJSON() {
        const data = JSON.stringify(currentConfig, null, 2);
        const blob = new Blob([data], { type: "application/json" });
        downloadBlob(blob, `gridchive-config-${Date.now()}.json`);
        showNotification("Configuration saved!");
      }

      function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      }

      function showNotification(message, type = "success") {
        // Simple notification system
        const notification = document.createElement("div");
        notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: .6rem 1.2rem;
                background: ${type === "error" ? "#ef4444" : "#10b981"};
                color: white;
                border-radius: 2rem;
                font-size: 14px;
                z-index: 2000;
                animation: slideIn 0.3s ease;
            `;
        notification.textContent = message;
        document.body.appendChild(notification);

        setTimeout(() => {
          notification.style.animation = "slideOut 0.3s ease";
          setTimeout(() => notification.remove(), 300);
        }, 3000);
      }

      // Initialize
      setupControls();
      updateToolbar();
      generateGrid();
      generateVariations();

      // Handle window resize
      let resizeTimeout;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          if (window.innerWidth > 1024) {
            document
              .getElementById("sidebar")
              .classList.remove("mobile-hidden");
          }
        }, 250);
      });
    </script>
  </body>
</html>
